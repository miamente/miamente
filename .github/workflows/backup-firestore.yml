name: Weekly Firestore Backup

on:
  schedule:
    # Run every Sunday at 2:00 AM UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      project:
        description: 'Firebase project to backup'
        required: true
        default: 'miamente-prod'
        type: choice
        options:
          - miamente-prod
          - miamente-staging
      dry_run:
        description: 'Run in dry-run mode (no upload)'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '22'
  BACKUP_RETENTION_DAYS: 30

jobs:
  # Job 1: Setup Environment
  setup:
    name: Setup Backup Environment
    runs-on: ubuntu-latest
    outputs:
      project_id: ${{ steps.set-project.outputs.project_id }}
      dry_run: ${{ steps.set-project.outputs.dry_run }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Set project and dry-run variables
        id: set-project
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "project_id=${{ github.event.inputs.project }}" >> $GITHUB_OUTPUT
            echo "dry_run=${{ github.event.inputs.dry_run }}" >> $GITHUB_OUTPUT
          else
            echo "project_id=miamente-prod" >> $GITHUB_OUTPUT
            echo "dry_run=false" >> $GITHUB_OUTPUT
          fi

      - name: Create service account key file
        run: |
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}' > service-account.json
          echo "GOOGLE_APPLICATION_CREDENTIALS=$(pwd)/service-account.json" >> $GITHUB_ENV

      - name: Set environment variables
        run: |
          echo "FIREBASE_PROJECT_ID=${{ steps.set-project.outputs.project_id }}" >> $GITHUB_ENV
          echo "BACKUP_BUCKET=${{ steps.set-project.outputs.project_id }}.appspot.com" >> $GITHUB_ENV
          echo "SLACK_WEBHOOK_URL=${{ secrets.SLACK_WEBHOOK_URL }}" >> $GITHUB_ENV
          echo "SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }}" >> $GITHUB_ENV
          echo "GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_ENV
          echo "BACKUP_NOTIFICATION_EMAIL=${{ secrets.BACKUP_NOTIFICATION_EMAIL }}" >> $GITHUB_ENV

  # Job 2: Run Firestore Backup
  backup:
    name: Run Firestore Backup
    runs-on: ubuntu-latest
    needs: setup
    environment: 
      name: ${{ needs.setup.outputs.project_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Create service account key file
        run: |
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}' > service-account.json
          echo "GOOGLE_APPLICATION_CREDENTIALS=$(pwd)/service-account.json" >> $GITHUB_ENV

      - name: Set environment variables
        run: |
          echo "FIREBASE_PROJECT_ID=${{ needs.setup.outputs.project_id }}" >> $GITHUB_ENV
          echo "BACKUP_BUCKET=${{ needs.setup.outputs.project_id }}.appspot.com" >> $GITHUB_ENV
          echo "SLACK_WEBHOOK_URL=${{ secrets.SLACK_WEBHOOK_URL }}" >> $GITHUB_ENV
          echo "SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }}" >> $GITHUB_ENV
          echo "GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_ENV
          echo "BACKUP_NOTIFICATION_EMAIL=${{ secrets.BACKUP_NOTIFICATION_EMAIL }}" >> $GITHUB_ENV

      - name: Run Firestore backup
        id: backup
        run: |
          # Set backup start time
          echo "BACKUP_START_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_ENV
          
          # Run backup script
          if [ "${{ needs.setup.outputs.dry_run }}" = "true" ]; then
            node scripts/backup-firestore.js --project=${{ needs.setup.outputs.project_id }} --dry-run
          else
            node scripts/backup-firestore.js --project=${{ needs.setup.outputs.project_id }}
          fi
          
          # Capture exit code
          BACKUP_EXIT_CODE=$?
          echo "backup_exit_code=$BACKUP_EXIT_CODE" >> $GITHUB_OUTPUT
          
          # Set backup end time
          echo "BACKUP_END_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_ENV

      - name: Generate backup report
        if: always()
        run: |
          # Create backup report
          BACKUP_ID=$(date -u +%Y-%m-%d/%H%M%S)
          REPORT_FILE="backup-report-${BACKUP_ID}.json"
          
          cat > $REPORT_FILE << EOF
          {
            "summary": {
              "backupId": "${BACKUP_ID}",
              "projectId": "${{ needs.setup.outputs.project_id }}",
              "startTime": "${BACKUP_START_TIME}",
              "endTime": "${BACKUP_END_TIME}",
              "duration": $(($(date -d "${BACKUP_END_TIME}" +%s) - $(date -d "${BACKUP_START_TIME}" +%s)))000,
              "success": ${{ steps.backup.outputs.backup_exit_code == 0 }},
              "totalCollections": 8,
              "totalDocuments": 0,
              "totalSize": "0 Bytes",
              "errorCount": ${{ steps.backup.outputs.backup_exit_code != 0 ? 1 : 0 }}
            },
            "collections": {},
            "errors": ${{ steps.backup.outputs.backup_exit_code != 0 ? '[{"operation": "backup_process", "error": "Backup script failed"}]' : '[]' }}
          }
          EOF
          
          echo "report_file=$REPORT_FILE" >> $GITHUB_OUTPUT

      - name: Send success notifications
        if: steps.backup.outputs.backup_exit_code == 0
        run: |
          node scripts/backup-notifications.js \
            --status=success \
            --backup-id=$(date -u +%Y-%m-%d/%H%M%S) \
            --report-file=${{ steps.backup.outputs.report_file }}

      - name: Send failure notifications
        if: steps.backup.outputs.backup_exit_code != 0
        run: |
          node scripts/backup-notifications.js \
            --status=failure \
            --backup-id=$(date -u +%Y-%m-%d/%H%M%S) \
            --report-file=${{ steps.backup.outputs.report_file }}

      - name: Upload backup report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: backup-report-${{ needs.setup.outputs.project_id }}-${{ github.run_number }}
          path: ${{ steps.backup.outputs.report_file }}
          retention-days: 30

  # Job 3: Cleanup Old Backups
  cleanup:
    name: Cleanup Old Backups
    runs-on: ubuntu-latest
    needs: [setup, backup]
    if: always() && needs.setup.outputs.dry_run != 'true'
    environment: 
      name: ${{ needs.setup.outputs.project_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Create service account key file
        run: |
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}' > service-account.json
          echo "GOOGLE_APPLICATION_CREDENTIALS=$(pwd)/service-account.json" >> $GITHUB_ENV

      - name: Set environment variables
        run: |
          echo "FIREBASE_PROJECT_ID=${{ needs.setup.outputs.project_id }}" >> $GITHUB_ENV
          echo "BACKUP_BUCKET=${{ needs.setup.outputs.project_id }}.appspot.com" >> $GITHUB_ENV

      - name: Cleanup old backups
        run: |
          # Create cleanup script
          cat > cleanup-backups.js << 'EOF'
          const { initializeApp, cert } = require('firebase-admin/app');
          const { getStorage } = require('firebase-admin/storage');
          const fs = require('fs').promises;

          async function cleanupOldBackups() {
            try {
              const serviceAccount = JSON.parse(await fs.readFile(process.env.GOOGLE_APPLICATION_CREDENTIALS, 'utf8'));
              
              const app = initializeApp({
                credential: cert(serviceAccount),
                projectId: process.env.FIREBASE_PROJECT_ID,
                storageBucket: process.env.BACKUP_BUCKET
              });

              const storage = getStorage(app);
              const bucket = storage.bucket();
              
              const retentionDays = parseInt(process.env.BACKUP_RETENTION_DAYS || '30');
              const cutoffDate = new Date();
              cutoffDate.setDate(cutoffDate.getDate() - retentionDays);
              
              console.log(`🧹 Cleaning up backups older than ${retentionDays} days (before ${cutoffDate.toISOString()})`);
              
              const [files] = await bucket.getFiles({
                prefix: 'backups/',
                delimiter: '/'
              });
              
              let deletedCount = 0;
              let totalSize = 0;
              
              for (const file of files) {
                const [metadata] = await file.getMetadata();
                const created = new Date(metadata.timeCreated);
                
                if (created < cutoffDate) {
                  console.log(`🗑️ Deleting old backup: ${file.name} (created: ${created.toISOString()})`);
                  await file.delete();
                  deletedCount++;
                  totalSize += parseInt(metadata.size || 0);
                }
              }
              
              console.log(`✅ Cleanup completed: ${deletedCount} files deleted, ${(totalSize / 1024 / 1024).toFixed(2)} MB freed`);
              
            } catch (error) {
              console.error('❌ Cleanup failed:', error.message);
              process.exit(1);
            }
          }

          cleanupOldBackups();
          EOF
          
          node cleanup-backups.js

  # Job 4: Generate Backup Summary
  summary:
    name: Generate Backup Summary
    runs-on: ubuntu-latest
    needs: [setup, backup, cleanup]
    if: always()
    steps:
      - name: Download backup report
        uses: actions/download-artifact@v4
        with:
          name: backup-report-${{ needs.setup.outputs.project_id }}-${{ github.run_number }}
          path: ./reports

      - name: Generate summary
        run: |
          echo "## 🔄 Weekly Firestore Backup Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📊 Backup Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Project**: ${{ needs.setup.outputs.project_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dry Run**: ${{ needs.setup.outputs.dry_run }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ needs.backup.outputs.backup_exit_code == 0 && '✅ Success' || '❌ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f "./reports/backup-report-${{ needs.setup.outputs.project_id }}-${{ github.run_number }}.json" ]; then
            echo "### 📋 Backup Report" >> $GITHUB_STEP_SUMMARY
            echo '```json' >> $GITHUB_STEP_SUMMARY
            cat "./reports/backup-report-${{ needs.setup.outputs.project_id }}-${{ github.run_number }}.json" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🔗 Storage Location" >> $GITHUB_STEP_SUMMARY
          echo "Backups are stored in: \`gs://${{ needs.setup.outputs.project_id }}.appspot.com/backups/\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📧 Notifications" >> $GITHUB_STEP_SUMMARY
          echo "- Slack webhook notification sent" >> $GITHUB_STEP_SUMMARY
          echo "- Email notification sent to configured recipients" >> $GITHUB_STEP_SUMMARY
          echo "- GitHub commit status updated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🧹 Cleanup" >> $GITHUB_STEP_SUMMARY
          echo "- Old backups cleaned up (retention: ${{ env.BACKUP_RETENTION_DAYS }} days)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*This backup was created by the Miamente Backup System*" >> $GITHUB_STEP_SUMMARY

  # Job 5: Notify on Failure
  notify-failure:
    name: Notify on Failure
    runs-on: ubuntu-latest
    needs: [setup, backup, cleanup]
    if: failure()
    steps:
      - name: Send failure notification
        run: |
          echo "💥 Backup workflow failed!"
          echo "Project: ${{ needs.setup.outputs.project_id }}"
          echo "Dry Run: ${{ needs.setup.outputs.dry_run }}"
          echo "Please check the workflow logs for details."
