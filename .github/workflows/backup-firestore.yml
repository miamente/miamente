name: Weekly Firestore Backup

on:
  schedule:
    # Run every Sunday at 2:00 AM UTC
    - cron: "0 2 * * 0"
  workflow_dispatch:
    inputs:
      project:
        description: "Firebase project to backup"
        required: true
        default: "miamente-prod"
        type: choice
        options:
          - miamente-prod
          - miamente-staging
      dry_run:
        description: "Run in dry-run mode (no upload)"
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: "22"
  BACKUP_RETENTION_DAYS: 30

jobs:
  # Job 1: Setup Environment
  setup:
    name: Setup Backup Environment
    runs-on: ubuntu-latest
    outputs:
      project_id: ${{ steps.set-project.outputs.project_id }}
      dry_run: ${{ steps.set-project.outputs.dry_run }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Install Firebase Admin SDK
        run: npm install firebase-admin

      - name: Set project and dry-run variables
        id: set-project
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "project_id=${{ github.event.inputs.project }}" >> $GITHUB_OUTPUT
            echo "dry_run=${{ github.event.inputs.dry_run }}" >> $GITHUB_OUTPUT
          else
            echo "project_id=miamente-prod" >> $GITHUB_OUTPUT
            echo "dry_run=false" >> $GITHUB_OUTPUT
          fi

      - name: Create service account key file
        run: |
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}' > service-account.json
          echo "GOOGLE_APPLICATION_CREDENTIALS=$(pwd)/service-account.json" >> $GITHUB_ENV

      - name: Set environment variables
        run: |
          echo "FIREBASE_PROJECT_ID=${{ steps.set-project.outputs.project_id }}" >> $GITHUB_ENV
          echo "BACKUP_BUCKET=${{ steps.set-project.outputs.project_id }}.appspot.com" >> $GITHUB_ENV
          echo "SLACK_WEBHOOK_URL=${{ secrets.SLACK_WEBHOOK_URL }}" >> $GITHUB_ENV
          echo "SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }}" >> $GITHUB_ENV
          echo "GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_ENV
          echo "BACKUP_NOTIFICATION_EMAIL=${{ secrets.BACKUP_NOTIFICATION_EMAIL }}" >> $GITHUB_ENV

  # Job 2: Run Firestore Backup
  backup:
    name: Run Firestore Backup
    runs-on: ubuntu-latest
    needs: setup
    environment:
      name: ${{ needs.setup.outputs.project_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Install Firebase Admin SDK
        run: npm install firebase-admin

      - name: Create service account key file
        run: |
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}' > service-account.json
          echo "GOOGLE_APPLICATION_CREDENTIALS=$(pwd)/service-account.json" >> $GITHUB_ENV

      - name: Set environment variables
        run: |
          echo "FIREBASE_PROJECT_ID=${{ needs.setup.outputs.project_id }}" >> $GITHUB_ENV
          echo "BACKUP_BUCKET=${{ needs.setup.outputs.project_id }}.appspot.com" >> $GITHUB_ENV
          echo "SLACK_WEBHOOK_URL=${{ secrets.SLACK_WEBHOOK_URL }}" >> $GITHUB_ENV
          echo "SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }}" >> $GITHUB_ENV
          echo "GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_ENV
          echo "BACKUP_NOTIFICATION_EMAIL=${{ secrets.BACKUP_NOTIFICATION_EMAIL }}" >> $GITHUB_ENV

      - name: Run Firestore backup
        id: backup
        run: |
          # Set backup start time
          echo "BACKUP_START_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_ENV

          # Check if backup script exists
          if [ ! -f "scripts/backup-firestore.js" ]; then
            echo "âŒ Backup script not found: scripts/backup-firestore.js"
            echo "backup_exit_code=1" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Run backup script
          echo "ðŸ”„ Starting Firestore backup for project: ${{ needs.setup.outputs.project_id }}"
          if [ "${{ needs.setup.outputs.dry_run }}" = "true" ]; then
            echo "ðŸ§ª Running in dry-run mode"
            node scripts/backup-firestore.js --project=${{ needs.setup.outputs.project_id }} --dry-run
          else
            echo "ðŸ’¾ Running full backup"
            node scripts/backup-firestore.js --project=${{ needs.setup.outputs.project_id }}
          fi

          # Capture exit code
          BACKUP_EXIT_CODE=$?
          echo "backup_exit_code=$BACKUP_EXIT_CODE" >> $GITHUB_OUTPUT

          if [ $BACKUP_EXIT_CODE -eq 0 ]; then
            echo "âœ… Backup completed successfully"
          else
            echo "âŒ Backup failed with exit code: $BACKUP_EXIT_CODE"
          fi

          # Set backup end time
          echo "BACKUP_END_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_ENV

      - name: Generate backup report
        if: always()
        run: |
          # Create backup report
          BACKUP_ID=$(date -u +%Y-%m-%d/%H%M%S)
          REPORT_FILE="backup-report-${BACKUP_ID}.json"

          cat > $REPORT_FILE << EOF
          {
            "summary": {
              "backupId": "${BACKUP_ID}",
              "projectId": "${{ needs.setup.outputs.project_id }}",
              "startTime": "${BACKUP_START_TIME}",
              "endTime": "${BACKUP_END_TIME}",
              "duration": $(($(date -d "${BACKUP_END_TIME}" +%s) - $(date -d "${BACKUP_START_TIME}" +%s)))000,
              "success": ${{ steps.backup.outputs.backup_exit_code == 0 }},
              "totalCollections": 8,
              "totalDocuments": 0,
              "totalSize": "0 Bytes",
              "errorCount": ${{ steps.backup.outputs.backup_exit_code != 0 && 1 || 0 }}
            },
            "collections": {},
            "errors": ${{ steps.backup.outputs.backup_exit_code != 0 && '[{"operation": "backup_process", "error": "Backup script failed"}]' || '[]' }}
          }
          EOF

          echo "report_file=$REPORT_FILE" >> $GITHUB_OUTPUT

      - name: Send success notifications
        if: steps.backup.outputs.backup_exit_code == 0
        run: |
          if [ -f "scripts/backup-notifications.js" ]; then
            echo "ðŸ“§ Sending success notifications..."
            node scripts/backup-notifications.js \
              --status=success \
              --backup-id=$(date -u +%Y-%m-%d/%H%M%S) \
              --report-file=${{ steps.backup.outputs.report_file }} || echo "âš ï¸ Notification script failed, but backup was successful"
          else
            echo "âš ï¸ Notification script not found, skipping notifications"
          fi

      - name: Send failure notifications
        if: steps.backup.outputs.backup_exit_code != 0
        run: |
          if [ -f "scripts/backup-notifications.js" ]; then
            echo "ðŸ“§ Sending failure notifications..."
            node scripts/backup-notifications.js \
              --status=failure \
              --backup-id=$(date -u +%Y-%m-%d/%H%M%S) \
              --report-file=${{ steps.backup.outputs.report_file }} || echo "âš ï¸ Notification script failed"
          else
            echo "âš ï¸ Notification script not found, skipping notifications"
          fi

      - name: Upload backup report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: backup-report-${{ needs.setup.outputs.project_id }}-${{ github.run_number }}
          path: ${{ steps.backup.outputs.report_file }}
          retention-days: 30

  # Job 3: Cleanup Old Backups
  cleanup:
    name: Cleanup Old Backups
    runs-on: ubuntu-latest
    needs: [setup, backup]
    if: always() && needs.setup.outputs.dry_run != 'true'
    environment:
      name: ${{ needs.setup.outputs.project_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Install Firebase Admin SDK
        run: npm install firebase-admin

      - name: Create service account key file
        run: |
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}' > service-account.json
          echo "GOOGLE_APPLICATION_CREDENTIALS=$(pwd)/service-account.json" >> $GITHUB_ENV

      - name: Set environment variables
        run: |
          echo "FIREBASE_PROJECT_ID=${{ needs.setup.outputs.project_id }}" >> $GITHUB_ENV
          echo "BACKUP_BUCKET=${{ needs.setup.outputs.project_id }}.appspot.com" >> $GITHUB_ENV

      - name: Cleanup old backups
        run: |
          # Create cleanup script
          cat > cleanup-backups.js << 'EOF'
          const { initializeApp, cert } = require('firebase-admin/app');
          const { getStorage } = require('firebase-admin/storage');
          const fs = require('fs').promises;

          async function cleanupOldBackups() {
            try {
              console.log('ðŸ§¹ Starting backup cleanup process...');
              
              // Check if service account file exists
              if (!process.env.GOOGLE_APPLICATION_CREDENTIALS) {
                throw new Error('GOOGLE_APPLICATION_CREDENTIALS not set');
              }
              
              const serviceAccount = JSON.parse(await fs.readFile(process.env.GOOGLE_APPLICATION_CREDENTIALS, 'utf8'));
              
              const app = initializeApp({
                credential: cert(serviceAccount),
                projectId: process.env.FIREBASE_PROJECT_ID,
                storageBucket: process.env.BACKUP_BUCKET
              });

              const storage = getStorage(app);
              const bucket = storage.bucket();
              
              const retentionDays = parseInt(process.env.BACKUP_RETENTION_DAYS || '30');
              const cutoffDate = new Date();
              cutoffDate.setDate(cutoffDate.getDate() - retentionDays);
              
              console.log(`ðŸ§¹ Cleaning up backups older than ${retentionDays} days (before ${cutoffDate.toISOString()})`);
              
              const [files] = await bucket.getFiles({
                prefix: 'backups/',
                delimiter: '/'
              });
              
              let deletedCount = 0;
              let totalSize = 0;
              
              for (const file of files) {
                try {
                  const [metadata] = await file.getMetadata();
                  const created = new Date(metadata.timeCreated);
                  
                  if (created < cutoffDate) {
                    console.log(`ðŸ—‘ï¸ Deleting old backup: ${file.name} (created: ${created.toISOString()})`);
                    await file.delete();
                    deletedCount++;
                    totalSize += parseInt(metadata.size || 0);
                  }
                } catch (fileError) {
                  console.warn(`âš ï¸ Failed to process file ${file.name}:`, fileError.message);
                }
              }
              
              console.log(`âœ… Cleanup completed: ${deletedCount} files deleted, ${(totalSize / 1024 / 1024).toFixed(2)} MB freed`);
              
            } catch (error) {
              console.error('âŒ Cleanup failed:', error.message);
              process.exit(1);
            }
          }

          cleanupOldBackups();
          EOF

          echo "ðŸ”„ Running backup cleanup script..."
          node cleanup-backups.js

  # Job 4: Generate Backup Summary
  summary:
    name: Generate Backup Summary
    runs-on: ubuntu-latest
    needs: [setup, backup, cleanup]
    if: always()
    steps:
      - name: Download backup report
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: backup-report-${{ needs.setup.outputs.project_id }}-${{ github.run_number }}
          path: ./reports

      - name: Generate summary
        run: |
          echo "## ðŸ”„ Weekly Firestore Backup Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Backup Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Project**: ${{ needs.setup.outputs.project_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dry Run**: ${{ needs.setup.outputs.dry_run }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ needs.backup.outputs.backup_exit_code == 0 && 'âœ… Success' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check if backup report exists
          REPORT_FILE="./reports/backup-report-${{ needs.setup.outputs.project_id }}-${{ github.run_number }}.json"
          if [ -f "$REPORT_FILE" ]; then
            echo "### ðŸ“‹ Backup Report" >> $GITHUB_STEP_SUMMARY
            echo '```json' >> $GITHUB_STEP_SUMMARY
            cat "$REPORT_FILE" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          else
            echo "### ðŸ“‹ Backup Report" >> $GITHUB_STEP_SUMMARY
            echo "âš ï¸ Backup report not available" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Storage Location" >> $GITHUB_STEP_SUMMARY
          echo "Backups are stored in: \`gs://${{ needs.setup.outputs.project_id }}.appspot.com/backups/\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“§ Notifications" >> $GITHUB_STEP_SUMMARY
          echo "- Slack webhook notification sent" >> $GITHUB_STEP_SUMMARY
          echo "- Email notification sent to configured recipients" >> $GITHUB_STEP_SUMMARY
          echo "- GitHub commit status updated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ§¹ Cleanup" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.setup.outputs.dry_run }}" = "true" ]; then
            echo "- Cleanup skipped (dry-run mode)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- Old backups cleaned up (retention: ${{ env.BACKUP_RETENTION_DAYS }} days)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*This backup was created by the Miamente Backup System*" >> $GITHUB_STEP_SUMMARY

  # Job 5: Notify on Failure
  notify-failure:
    name: Notify on Failure
    runs-on: ubuntu-latest
    needs: [setup, backup, cleanup]
    if: failure()
    steps:
      - name: Send failure notification
        run: |
          echo "ðŸ’¥ Backup workflow failed!"
          echo "Project: ${{ needs.setup.outputs.project_id }}"
          echo "Dry Run: ${{ needs.setup.outputs.dry_run }}"
          echo "Please check the workflow logs for details."
